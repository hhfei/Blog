#### 创建对象的方式
+ new
+ 反射
+ 工厂模式


反射
Class clazz = Class.forName();
Class clazz = 类名.class;
Class clazz = 对象名.getClass()
Constructor ctor = clazz.getDeclareConstructor();
Object obj = ctor.newInstance();


BeanFactoryPostProcessor
创建bean之前的后置处理器，比如替换bean定义的参数



bean 的生命周期

- 实例化
- 填充属性
- 执行aware接口的需要实现的方法，aware接口的存在的意义是：方便通过spring的中的bean对象来获取
取对应容器中的相关属性值
- BeanPostProcessor.before
- init-method方法
- BeanPostProcessor.after
- 完整对象
- 销毁流程


### 循环依赖

单例  
三级缓存


实例化
初始化  
- set - 可以解决
- 构造方法 - 没有办法解决

实例化和初始化分开处理提前暴露对象

1. 三级缓存解决循环依赖问题的关键是什么？为什么通过提前暴露对象能解决？
实例化和初始化分开操作，在中间过程给其他对象赋值的时候，并不是一个完整对象
，而是把半成品对象赋值给其他对象

2. 如果只是使用一级缓存能不能解决问题？
不能，在整个处理过程中，缓存中的放的是半成品和成品对象，如果只有一级缓存，那么成品和半成品都会放在一级缓存
中，有可能在获取过程中获取到半成品对象，此时半成品对象是无法使用的，不能直接进行相关的处理，因此要把半成品和成品的存放空间分割
开来。

3. 只使用二级缓存行不行？为什么需要三级缓存？
如果我能保证所有的bean对象都不去调用getEarlyBeanReference次方法，使用二级缓存可以吗？
是的，如果保证所有的bean对象都不去调用此方法，就可以。
使用三级缓存的本质在于解决aop代理问题

4. 如果某个bean对象代理对象，那么会不会创建普通的bean对象？
会，

5. 为什么使用了三级缓存就可以解决这个问题？
当一个对象需要被代理的时候，在整个创建过程中是包含两个对象吧。一个是普通对象
一个代理生成的对象，bean默认都是单例，那么我在整个生命周期的处理环节中，一个beanname能对应两个对象吗？
不能，既然不能的换，保证我在使用的时候加一层判断，判断一下是否需要进行代理的处理。

6. 我怎么知道你什么时候使用呢？
因为不知道什么时候会调用，所以通过一个匿名内部类的方式，在使用的时候直接对普通对象进行覆盖操作，保证全局唯一！！！


- 一级缓存放成品对象
- 二级缓存放半成品
- 三级缓存放lambda表达式，来完成代理对象的覆盖过程




